---
title: "A simple way to model rankings with Stan using the exploded logit distribution"
author: "Bruno Nicenboim"
date: "`r Sys.Date()`"
categories: ["stats"]
tags: ["stan", "Bayesian", "r"]
bibliography: ["biblio.bib","r-references.bib"]
draft: false
---


```{r setup, include = FALSE}
papaja::r_refs("r-references.bib")

## Global options
options(#max.print="75",
        #width = 80,
        #tibble.width = 160,
        digits = 2)
knitr::opts_chunk$set(echo=TRUE,
	             cache=FALSE,
               prompt=FALSE,
               tidy=FALSE,
               comment=NA,
               message=FALSE,
               warning=TRUE)
knitr::opts_knit$set(width=80)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed)
set.seed(42) 
```

## The initial problem 


I've been asking around about this:

```{r echo=FALSE}
blogdown::shortcode('tweet', '1369217174699732995')
```

One useful clue was this one:

```{r echo=FALSE}
blogdown::shortcode('tweet', '1369226616312901637')
```


The distribution that I was describing is called an  [*exploded logit distribution*](https://en.wikipedia.org/wiki/Discrete_choice#exploded_logit).

![](https://media.giphy.com/media/3osxYCsLd9qgsgqpwI/giphy.gif)


(This model is also called the *rank ordered logit model* [@BEGGS19811] or Plackettâ€“Luce model due to @Plackett and @Luce1959.)

We'll see that it can be useful to describe *some* types of ranking data.


I'm going to load some R packages that will be useful throughout this post.

```{r}
library(dplyr) # Data manipulation
library(purrr) # List manipulation
library(ggplot2) # Nice plots
library(extraDistr) # More distributions
library(rcorpora) # Get random words
library(cmdstanr) # Lightweight Stan interface
library(bayesplot) # Nice Bayesian plots
```


## Ranking data

Ranking data appear when we care about the *underlying* order or ranking that certain elements have. We might want to know which are the best horses after looking at several races [@gakisetal2018], which is the best candidate for a job after a series of interviewers talked to several candidates. More in line with cognitive science, we might want to know which are the best possible completions for a sentence or the best exemplars of a category.


One way to assess get a ranking of exemplars of a category is to present them to participants and ask them to order them or a subset of them [see @Barsalou1985].

### A ranking simulation using pizza toppings.

![](https://media.giphy.com/media/3oEjHZhG9COPG6XjzO/giphy.gif)

Let's consider the following pizza toppings:

```{r}
toppings <- corpora("foods/pizzaToppings")$pizzaToppings
N_toppings <- length(toppings)

```
Let's say that there is an underlying universal order of pizza toppings. The toppings are ordered according to an underlying value, a probability, that also represents how likely they are to be given as *the* exemplar of their category.

To assign probabilities to the toppings, I draw random samples from a [Dirichlet distribution](https://en.wikipedia.org/wiki/Dirichlet_distribution). The Dirichlet distribution is the generalization of the Beta distribution, and similarly to the Beta distribution, one its concentration parameters are all ones it's uniform. By setting all the concentration parameters below one, I'm assuming sparsity, that is, many values close to zero. 

These is the true ranking that I'm assuming here:

```{r Probs}
alpha <- rep(.5, N_toppings)
P_toppings <- c(rdirichlet(1, alpha)) %>%
  setNames(toppings) %>%
  sort(decreasing = TRUE) %>%
  round(3)
P_toppings
```

Given these values, if I were to ask a participant "What's the most appropriate topping for a pizza?" I would assume that `r P_toppings[[1]]*100` percent of the time, I would get `r names(P_toppings[1])`.

Essentially,  we expect something like this to be happening.

$
response \sim Categorical(\Theta_{toppings})
$

With $\Theta_{toppings}$ representing the different probabilities for each topping. The probability mass function of the categorical distribution is absurdly simple: It's just the probability of the outcome.

$$p(x = i) = \Theta_i$$, where $i = \{$`r paste0(names(P_toppings), collapse = ", ")`$\}$. 


We can simulate this with 100 participants as follows:

```{r}
response <- rcat(100, P_toppings, names(P_toppings))
```

And this should match approximately `P_toppings`.

```{r table}
table(response)/100
```

Now, what happens if we ask about the second most appropriate topping for a pizza?

Now, for each participant, we need to exclude the first topping, and draw another sample from a categorical distribution. (We don't allow them to repeat, that is, to say that best topping is pineapple and second best is also pineapple). This means that now the probability of the item already given is zero, and that we need to normalize our original probability values by dividing it by the new total probability (which will be lower than 1).

Here, the probability of getting the element $j$ (where $j \neq i$) is

$$p(x = j) = \frac{\Theta_j}{\sum \Theta_{-i}}$$

where $\Theta_{-i}$ represents the probabilities of all the outcomes except of $i$, which was the first one. We can go on with the third best topping, where we need to normalize the remaining probabilities by dividing by the new sum of remaining probabilities.


$$p(x = k) = \frac{\Theta_k}{\sum \Theta_{-i,-j}}$$

Until we get to the last element, which will be drawn with probability 1.

**This is the exploded logit distribution.**

This process can be simulated in R as follows:

```{r rexploded}
rexploded <-  function(n, ranked = 3, prob, labels = NULL){
  #run n times
  lapply(1:n, function(nn){
    res <- rep(NA,ranked)
    if(!is.null(labels)){
      res <- factor(res, labels)
    } else {
      # if there are no labels, just 1,2,3,...
      labels <- seq_along(prob)
    }
  for(i in 1:ranked){
    # normalize the probability so that it sums to 1
    prob <- prob/sum(prob)
    res[i] <- rcat(1, prob = prob, labels = labels)
    # remove the choice from the set:
    prob[res[i]] <- 0
  }
    res
  })
}
```

If we would like to simulate 50 subjects that rank 5 ingredients out of the total in order of how good toppings they are, we would do the following:

```{r}
res <- rexploded(n = 50, ranked = 5, prob = P_toppings, labels = names(P_toppings))
# subject 1:
res[[1]]
```

```{r}
data_plot <- map_dfr(res,
                     ~ tibble(topping= .x) %>%
                       mutate(order = 1:n()),
                     .id="subject") %>%
  mutate(subject = as.numeric(subject))
ggplot(data_plot, aes(x=order, y = subject, label = topping, group = subject)) +
  geom_line() +
  geom_label() +
  theme_minimal()
```

We have simulated a ranking of pizza toppings, can we recover the original probability values and "discover" the underlying order?

## Fitting the exploded logistic distribution in Stan

To fit the model in Stan, I'm going to create a custom probability mass function that takes an array of integers, `x`, which represent a set of rankings, and a vector of probability values, `theta`, that sums up to one.

The logic of this function is that the probability mass function of a ranking $\{i,j,k, \ldots, N \}$ can be written as a product of normalized categorical distributions (where the first one is just divided by 1).

$$p(x = \{i,j,k,\ldots\}) = \frac{\Theta_i}{\sum \Theta} \cdot \frac{\Theta_j}{ \Theta_{-i}} \cdot \frac{\Theta_k}{ \Theta_{-i, -j}} \ldots$$

In log-space products become sums, and divisions a difference, and the log of \sum \Theta will be zero:

$$log(p(x = \{i,j,k,\ldots\})) = \log(\Theta_i) - log(\sum \Theta) + \log(\Theta_j) -  \log(\Theta_{-i}) + \log(\Theta_k) -\log( \Theta_{-i, -j}) + \ldots$$

The custom function follows this logic but iterating over the rankings, and in each iteration, it aggregates in `out` the addends of the log probability mass function, and turns the probability of selecting again the ranked element to zero.

```
 real exploded_lpmf(int[] x, vector Theta){
    real out = 0;
    vector[num_elements(Theta)] thetar = Theta;
    for(pos in x){
      out += log(thetar[pos]) - log(sum(thetar));
      thetar[pos] = 0;
      }
     return(out);
 }
```

The whole model named `exploded.stan` includes, the usual data declaration, the parameter `Theta` declared as a simplex (i.e., it sums to one), and a uniform Dirichlet prior for `Theta`.

```{stan output.var = "exploded", code = readLines("exploded.stan"),  tidy = TRUE, comment="", eval = FALSE, cache = FALSE, cache.lazy = FALSE}
```

Let's see if I can recover the parameter values.

```{r}
ldata <- list(res = lapply(res, as.numeric),
              N_ranked = length(res[[1]]), #5
              N_options = length(P_toppings), #25
              N_ranking = length(res)) # 10


m_expl <- cmdstan_model("./exploded.stan")

f_exploded <- m_expl$sample(
  data = ldata,
  seed = 123,
  parallel_chains = 4
)

f_exploded
```

I plot the posterior distributions of the probability values and the true probability values below.

```{r}
mcmc_recover_hist(f_exploded$draws("Theta"), P_toppings)
```

## Caveats

Not a cognitive model ....


## Session info

I used `r papaja::cite_r("r-references.bib")` to generate this document.

```{r}
sessionInfo()
```

## References
