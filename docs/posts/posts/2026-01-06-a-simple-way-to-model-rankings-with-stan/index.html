<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Bruno Nicenboim">
<meta name="dcterms.date" content="2026-01-07">
<meta name="description" content="How to fit the exploded logit distribution in Stan to model ranking data">

<title>A simple way to model rankings with Stan – Bruno Nicenboim</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-6702ebd02cba8b53d0df9107bd4fc31d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Bruno Nicenboim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../publications.html"> 
<span class="menu-text">Publications and presentations</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../team.html"> 
<span class="menu-text">Team</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../software.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../posts/index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="../../../posts/index.xml"> <i class="bi bi-rss" role="img" aria-label="RSS Feed">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-initial-problem" id="toc-the-initial-problem" class="nav-link active" data-scroll-target="#the-initial-problem">The initial problem</a></li>
  <li><a href="#ranking-data" id="toc-ranking-data" class="nav-link" data-scroll-target="#ranking-data">Ranking data</a>
  <ul class="collapse">
  <li><a href="#a-ranking-simulation-using-pizza-toppings" id="toc-a-ranking-simulation-using-pizza-toppings" class="nav-link" data-scroll-target="#a-ranking-simulation-using-pizza-toppings">A ranking simulation using pizza toppings</a></li>
  </ul></li>
  <li><a href="#fitting-the-exploded-logistic-distribution-in-stan" id="toc-fitting-the-exploded-logistic-distribution-in-stan" class="nav-link" data-scroll-target="#fitting-the-exploded-logistic-distribution-in-stan">Fitting the exploded logistic distribution in Stan</a></li>
  <li><a href="#what-is-this-good-for" id="toc-what-is-this-good-for" class="nav-link" data-scroll-target="#what-is-this-good-for">What is this good for?</a></li>
  <li><a href="#could-this-be-used-as-a-cognitive-model-of-peoples-rankings" id="toc-could-this-be-used-as-a-cognitive-model-of-peoples-rankings" class="nav-link" data-scroll-target="#could-this-be-used-as-a-cognitive-model-of-peoples-rankings">Could this be used as a cognitive model of people’s rankings?</a></li>
  <li><a href="#how-to-cite-this-post" id="toc-how-to-cite-this-post" class="nav-link" data-scroll-target="#how-to-cite-this-post">How to cite this post</a></li>
  <li><a href="#session-info" id="toc-session-info" class="nav-link" data-scroll-target="#session-info">Session info</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">A simple way to model rankings with Stan</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Stan</div>
    <div class="quarto-category">Bayesian</div>
    <div class="quarto-category">R</div>
    <div class="quarto-category">Citable</div>
  </div>
  </div>

<div>
  <div class="description">
    How to fit the exploded logit distribution in Stan to model ranking data
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Bruno Nicenboim </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 7, 2026</p>
    </div>
  </div>
  
    
    <div>
    <div class="quarto-title-meta-heading">Doi</div>
    <div class="quarto-title-meta-contents">
      <p class="doi">
        <a href="https://doi.org/10.5281/zenodo.18171805">10.5281/zenodo.18171805</a>
      </p>
    </div>
  </div>
  </div>
  


</header>


<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Update Notice
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>This is an updated version of a post originally published on March 21, 2021.</strong></p>
<p>I’ve updated this post in January 2026 to work with current versions of Stan and R packages. The main changes include:</p>
<ul>
<li><p>Updated Stan syntax to current standards</p></li>
<li><p>Using cmdstanr instead of rstan and some other R packages.</p></li>
</ul>
<p>The core content and ideas remain the same.</p>
</div>
</div>
<section id="the-initial-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-initial-problem">The initial problem</h2>
<p>I wrote what I thought was the generative process for some modeling work, and it looked too common to not have a name, so I started asking around on what it was a very popular website back in 2021, <a href="https://en.wikipedia.org/wiki/Twitter">Twitter</a>.</p>
<p>One useful clue was about the <a href="https://en.wikipedia.org/wiki/Discrete_choice#exploded_logit"><em>exploded logit distribution</em></a>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p><img src="https://media.giphy.com/media/3osxYCsLd9qgsgqpwI/giphy.gif" class="img-fluid"></p>
<p>In this post, I’ll show how this model can be fit in the probabilistic programming language <a href="https://mc-stan.org/">Stan</a>, and how it can be used to describe the underlying order of ranking data.</p>
<p>I’m going to load some R packages that will be useful throughout this post.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidytable) <span class="co"># Nicer alternative to dplyr and purrr</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2) <span class="co"># Nice plots</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(extraDistr) <span class="co"># More distributions</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rcorpora) <span class="co"># Get random words</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cmdstanr) <span class="co"># Lightweight Stan interface</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(bayesplot) <span class="co"># Nice Bayesian plots</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">42</span>)  <span class="co"># Keep everything R the same (not for Stan though)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="ranking-data" class="level2">
<h2 class="anchored" data-anchor-id="ranking-data">Ranking data</h2>
<p>Ranking data appear when we care about the <em>underlying</em> order that certain elements have. We might want to know which are the best horses after looking at several races <span class="citation" data-cites="gakisetal2018">(<a href="#ref-gakisetal2018" role="doc-biblioref">Gakis et al. 2018</a>)</span>, which is the best candidate for a job after a series of interviewers talked to several candidates. More in line with cognitive science, we might want to know which are the best possible completions for a sentence or the best exemplars of a category.</p>
<p>One way to get a ranking of exemplars of a category, for example, is to present them to participants and ask them to order all (or a subset) of them <span class="citation" data-cites="Barsalou1985">(see <a href="#ref-Barsalou1985" role="doc-biblioref">Barsalou 1985</a>)</span>.</p>
<section id="a-ranking-simulation-using-pizza-toppings" class="level3">
<h3 class="anchored" data-anchor-id="a-ranking-simulation-using-pizza-toppings">A ranking simulation using pizza toppings</h3>
<p><img src="https://media.giphy.com/media/3oEjHZhG9COPG6XjzO/giphy.gif" class="img-fluid"></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>toppings <span class="ot">&lt;-</span> <span class="fu">corpora</span>(<span class="st">"foods/pizzaToppings"</span>)<span class="sc">$</span>pizzaToppings</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>N_toppings <span class="ot">&lt;-</span> <span class="fu">length</span>(toppings)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>toppings</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "anchovies"        "artichoke"       
 [3] "bacon"            "breakfast bacon" 
 [5] "Canadian bacon"   "cheese"          
 [7] "chicken"          "chili peppers"   
 [9] "feta"             "garlic"          
[11] "green peppers"    "grilled onions"  
[13] "ground beef"      "ham"             
[15] "hot sauce"        "meatballs"       
[17] "mushrooms"        "olives"          
[19] "onions"           "pepperoni"       
[21] "pineapple"        "sausage"         
[23] "spinach"          "sun-dried tomato"
[25] "tomatoes"        </code></pre>
</div>
</div>
<p>Let’s say that we want to know the underlying order of pizza toppings. For the modeling, I’m going to assume that the toppings are ordered according to an underlying value, which also represents how likely it is for each topping to be <em>the</em> exemplar of their category.</p>
<p>To get a known ground truth for the ranking, I’m going to simulate an order of pizza toppings. I assign probabilities that sum up to one to the toppings by drawing a random sample from a <a href="https://en.wikipedia.org/wiki/Dirichlet_distribution">Dirichlet distribution</a>. The Dirichlet distribution is the generalization of the Beta distribution. It has a concentration parameter, usually <span class="math inline">\(\boldsymbol{\alpha}\)</span>, which is a vector as long as the probabilities we are sampling (25 here). When the vector is full of ones, the distribution is uniform: All probabilities are equally likely, so on average each one is <span class="math inline">\(\frac{1}{\text{vector length}}\)</span> (<span class="math inline">\(\frac{1}{25}\)</span> here). By setting all the concentration parameters below one (namely <span class="math inline">\(0.2\)</span>), I’m enforcing sparsity in the random values that I’m generating, that is, many probability values close to zero.</p>
<p>These is the true order that I’m assuming here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># all elements of the vector are 0.2</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> <span class="fu">rep</span>(.<span class="dv">2</span>, N_toppings)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate one draw from a Dirichlet distribution</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>P_toppings <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rdirichlet</span>(<span class="dv">1</span>, alpha)) <span class="sc">%&gt;%</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Add names</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">setNames</span>(toppings) <span class="sc">%&gt;%</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sort from the best exemplar</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sort</span>(<span class="at">decreasing =</span> <span class="cn">TRUE</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>P_toppings <span class="sc">%&gt;%</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">round</span>(<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> breakfast bacon          chicken             feta 
           0.294            0.241            0.087 
       anchovies sun-dried tomato           olives 
           0.087            0.077            0.057 
       pepperoni        artichoke           cheese 
           0.056            0.049            0.010 
  Canadian bacon            bacon              ham 
           0.008            0.008            0.006 
       meatballs    chili peppers           garlic 
           0.004            0.004            0.004 
     ground beef         tomatoes        hot sauce 
           0.003            0.003            0.002 
          onions          sausage        pineapple 
           0.000            0.000            0.000 
         spinach        mushrooms   grilled onions 
           0.000            0.000            0.000 
   green peppers 
           0.000 </code></pre>
</div>
</div>
<ul>
<li>Given these values, if I were to ask a participant “What’s the most appropriate topping for a pizza?” I would assume that 29.37 percent of the time, I would get <em>breakfast bacon</em>.</li>
</ul>
<p>Essentially, we expect something like this to be happening:</p>
<p><span class="math display">\[
\text{response} \sim \text{Categorical}(\Theta_{\text{toppings}})
\]</span></p>
<p>With <span class="math inline">\(\Theta_{\text{toppings}}\)</span> representing the different probabilities for each topping. The probability mass function of the categorical distribution is absurdly simple: It’s just the probability of the outcome.</p>
<p><span class="math display">\[
p(x = i) = \Theta_i
\]</span></p>
<p>where <span class="math inline">\(i = \{\)</span>breakfast bacon, chicken, feta, anchovies, sun-dried tomato, olives, pepperoni, artichoke, cheese, Canadian bacon, bacon, ham, meatballs, chili peppers, garlic, ground beef, tomatoes, hot sauce, onions, sausage, pineapple, spinach, mushrooms, grilled onions, green peppers<span class="math inline">\(\}\)</span>.</p>
<p>We can simulate this with 100 participants as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>response <span class="ot">&lt;-</span> <span class="fu">rcat</span>(<span class="dv">100</span>, P_toppings, <span class="fu">names</span>(P_toppings))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And this should match approximately <code>P_toppings</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(response)<span class="sc">/</span><span class="dv">100</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>response
 breakfast bacon          chicken             feta 
            0.26             0.19             0.16 
       anchovies sun-dried tomato           olives 
            0.07             0.15             0.06 
       pepperoni        artichoke           cheese 
            0.01             0.08             0.00 
  Canadian bacon            bacon              ham 
            0.02             0.00             0.00 
       meatballs    chili peppers           garlic 
            0.00             0.00             0.00 
     ground beef         tomatoes        hot sauce 
            0.00             0.00             0.00 
          onions          sausage        pineapple 
            0.00             0.00             0.00 
         spinach        mushrooms   grilled onions 
            0.00             0.00             0.00 
   green peppers 
            0.00 </code></pre>
</div>
</div>
<p><em>It seems that by only asking participants to give the best topping we could already deduce the underlying order…</em></p>
<p>True, but one motivation for considering ranking data is the amount of information that we gather with a list due to their combinatorial nature. If we ask participants to rank <span class="math inline">\(n\)</span> items, an answer consists in making a single selection out of <span class="math inline">\(n!\)</span> possibilities. Ordering 7 pizza toppings, for example, constitutes making a single selection out of 5040 possibilities!</p>
<p>If we don’t relay on lists and there is sparcity, it requires a large number of participants until we get answers of low probability. (For example, we’ll need a very large number of participants until we hear something else but <em>hammer</em> as an exemplar of tools).</p>
<ul>
<li>Now, what happens if we ask about the second most appropriate topping for a pizza?</li>
</ul>
<p>Now we need to exclude the first topping that was given, and draw another sample from a categorical distribution. (We don’t allow the participant to repeat toppings, that is, to say that the best topping is pineapple and the second best is also pineapple). This means that now the probability of the topping already given is zero, and that we need to normalize our original probability values by dividing them by the new total probability (which will be lower than 1).</p>
<p>Here, the probability of getting the element <span class="math inline">\(j\)</span> (where <span class="math inline">\(j \neq i\)</span>) is</p>
<p><span class="math display">\[
p(x = j) = \frac{\Theta_j}{\sum \Theta_{[-i]}}
\]</span></p>
<p>where <span class="math inline">\(\Theta_{[-i]}\)</span> represents the probabilities of all the outcomes except of <span class="math inline">\(i\)</span>, which was the first one.</p>
<ul>
<li>We can go on with the third best topping, where we need to normalize the remaining probabilities by dividing by the new sum of probabilities (e.g., we remove elements <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>).</li>
</ul>
<p><span class="math display">\[
p(x = k) = \frac{\Theta_k}{\sum \Theta_{[-i,-j]}}
\]</span></p>
<ul>
<li>We can do this until we get to the last element, which will be drawn with probability 1.</li>
</ul>
<p><strong>And this is the exploded logit distribution.</strong></p>
<p>This process can be simulated in R as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>rexploded <span class="ot">&lt;-</span>  <span class="cf">function</span>(n, <span class="at">ranked =</span> <span class="dv">3</span>, prob, <span class="at">labels =</span> <span class="cn">NULL</span>){</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># run n times</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span>n, <span class="cf">function</span>(nn){</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    res <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, ranked)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.null</span>(labels)){</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>      res <span class="ot">&lt;-</span> <span class="fu">factor</span>(res, labels)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>      <span class="co"># if there are no labels, just 1,2,3,...</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>      labels <span class="ot">&lt;-</span> <span class="fu">seq_along</span>(prob)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>ranked){</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>      <span class="co"># normalize the probability so that it sums to 1</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>      prob <span class="ot">&lt;-</span> prob<span class="sc">/</span><span class="fu">sum</span>(prob)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>      res[i] <span class="ot">&lt;-</span> <span class="fu">rcat</span>(<span class="dv">1</span>, <span class="at">prob =</span> prob, <span class="at">labels =</span> labels)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>      <span class="co"># remove the choice from the set:</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>      prob[res[i]] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    res</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we would like to simulate 50 subjects creating a ranking of the best 7 toppings, we would do the following:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">rexploded</span>(<span class="at">n =</span> <span class="dv">50</span>,</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                 <span class="at">ranked =</span> <span class="dv">7</span>,</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                 <span class="at">prob =</span> P_toppings,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                 <span class="at">labels =</span> <span class="fu">names</span>(P_toppings))</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"># subject 1:</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>res[[<span class="dv">1</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] sun-dried tomato artichoke        olives          
[4] breakfast bacon  chicken          pepperoni       
[7] anchovies       
25 Levels: breakfast bacon chicken feta ... green peppers</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/subjects-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We have simulated ranking data of pizza toppings, can we recover the original probability values and “discover” the underlying order?</p>
</section>
</section>
<section id="fitting-the-exploded-logistic-distribution-in-stan" class="level2">
<h2 class="anchored" data-anchor-id="fitting-the-exploded-logistic-distribution-in-stan">Fitting the exploded logistic distribution in Stan</h2>
<p>To fit the model in Stan, I’m going to create a custom probability mass function that takes an array of integers, <code>x</code>, which represents a set of rankings, and a vector of probability values, <code>theta</code>, that sums up to one.</p>
<p>The logic of this function is that the probability mass function of a ranking <span class="math inline">\(\{i,j,k, \ldots, N \}\)</span> can be written as a product of normalized categorical distributions (where the first one is just divided by 1).</p>
<p><span class="math display">\[
p(x = \{i,j,k,\ldots\}) = \frac{\Theta_i}{\sum \Theta} \cdot \frac{\Theta_j}{\sum \Theta_{[-i]}} \cdot \frac{\Theta_k}{\sum \Theta_{[-i, -j]}} \ldots
\]</span></p>
<p>For Stan, we need the log-PDF. In log-space, products become sums, and divisions differences, and the log of <span class="math inline">\(\sum \Theta\)</span> will be zero:</p>
<p><span class="math display">\[
\begin{aligned}
\log(p(x = \{i,j,k,\ldots\})) =&amp; \log(\Theta_i) - \log(\sum \Theta) \\
&amp; + \log(\Theta_j) - \log(\sum \Theta_{[-i]}) \\
&amp;+ \log(\Theta_k) - \log(\sum \Theta_{[-i, -j]}) \\
&amp; + \ldots
\end{aligned}
\]</span></p>
<p>The following Stan code has a custom function that follows this logic but iterating over the rankings. In each iteration, it aggregates in the variable <code>out</code> the addends of the log probability mass function, and turns the probability of selecting again the already ranked element to zero. I save this code as <code>"exploded.stan"</code>.</p>
<div class="cell" data-output.var="exploded">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">functions</span> {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> exploded_lpmf(<span class="dt">array</span>[] <span class="dt">int</span> x, <span class="dt">vector</span> Theta){</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real</span> out = <span class="dv">0</span>;</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vector</span>[num_elements(Theta)] thetar = Theta;</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(pos <span class="cf">in</span> x){</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      out += log(thetar[pos]) - log(sum(thetar));</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>      thetar[pos] = <span class="dv">0</span>;</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(out);</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span>{</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> N_ranking; <span class="co">// total times the choices were ranked</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> N_ranked; <span class="co">// total choices ranked</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> N_options; <span class="co">// total options</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">array</span>[N_ranking, N_ranked] <span class="dt">int</span> res;</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">simplex</span>[N_options] Theta;</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">target +=</span> dirichlet_lpdf(Theta | rep_vector(<span class="dv">1</span>, N_options));</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(r <span class="cf">in</span> <span class="dv">1</span>:N_ranking){</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">target +=</span> exploded_lpmf(res[r] | Theta);</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The whole model includes the usual data declaration, the parameter <code>Theta</code> declared as a simplex (i.e., it sums to one), and a uniform Dirichlet prior for <code>Theta</code>. (I’m assuming that I don’t know how sparse the probabilities are).</p>
<p>Let’s see if I can recover the parameter values.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Make the list of lists into a matrix</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>res_matrix <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">sapply</span>(res, as.numeric))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>ldata <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">res =</span> res_matrix, </span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">N_ranked =</span> <span class="fu">length</span>(res[[<span class="dv">1</span>]]), </span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">N_options =</span> <span class="fu">length</span>(P_toppings), </span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">N_ranking =</span> <span class="fu">length</span>(res)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>) </span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>m_expl <span class="ot">&lt;-</span> <span class="fu">cmdstan_model</span>(<span class="st">"exploded.stan"</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>f_exploded <span class="ot">&lt;-</span> m_expl<span class="sc">$</span><span class="fu">sample</span>(</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> ldata,</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  <span class="at">seed =</span> <span class="dv">123</span>,</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">parallel_chains =</span> <span class="dv">4</span>,</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>  <span class="at">refresh =</span> <span class="dv">0</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>f_exploded</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> variable    mean  median   sd  mad      q5     q95 rhat
 lp__     -724.97 -724.61 3.65 3.57 -731.42 -719.65 1.00
 Theta[1]    0.29    0.29 0.04 0.04    0.23    0.35 1.00
 Theta[2]    0.27    0.27 0.04 0.03    0.21    0.33 1.00
 Theta[3]    0.08    0.08 0.01 0.01    0.06    0.10 1.00
 Theta[4]    0.09    0.08 0.01 0.01    0.06    0.11 1.00
 Theta[5]    0.07    0.07 0.01 0.01    0.05    0.09 1.00
 Theta[6]    0.05    0.04 0.01 0.01    0.03    0.06 1.00
 Theta[7]    0.04    0.04 0.01 0.01    0.03    0.06 1.00
 Theta[8]    0.05    0.05 0.01 0.01    0.03    0.06 1.00
 Theta[9]    0.01    0.01 0.00 0.00    0.00    0.02 1.00
 ess_bulk ess_tail
     1637     2191
     5941     3310
     4884     3247
     5410     2878
     5771     2956
     5578     3435
     5973     3091
     6068     2815
     5606     3141
     6586     3244

 # showing 10 of 26 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option)</code></pre>
</div>
</div>
<p>I plot the posterior distributions of the probability values and the true probability values below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mcmc_recover_hist</span>(f_exploded<span class="sc">$</span><span class="fu">draws</span>(<span class="st">"Theta"</span>),</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>                  P_toppings,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">facet_args =</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">list</span>(<span class="at">scales =</span> <span class="st">"fixed"</span>, <span class="at">ncol =</span> <span class="dv">3</span>)) <span class="sc">+</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"bottom"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/recovery-plot-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>It looks reasonable. However, if we really want to be sure that this is working, we should probably use simulation based calibration <span class="citation" data-cites="taltsValidatingBayesianInference2018">(<a href="#ref-taltsValidatingBayesianInference2018" role="doc-biblioref">Talts et al. 2018</a>)</span>.</p>
</section>
<section id="what-is-this-good-for" class="level2">
<h2 class="anchored" data-anchor-id="what-is-this-good-for">What is this good for?</h2>
<p>This super simple example shows how to get an underlying ranking based on a set of responses from a number of subjects. It’s straightforward to adapt this model to data from participants ranking elements from different sets of the <em>same size</em> (e.g., 7 out of 25 toppings, 7 out of 25 tools). It’s a little less straightforward if the sets are of different sizes, e.g., rank 7 toppings out 25, but 7 tools out 50. This is just because Stan doesn’t allow ragged arrays. See <a href="https://discourse.mc-stan.org/t/ragged-array-of-simplexes/1382/31">this Stan Discourse thread</a> for some tips on implementing the latter model.</p>
</section>
<section id="could-this-be-used-as-a-cognitive-model-of-peoples-rankings" class="level2">
<h2 class="anchored" data-anchor-id="could-this-be-used-as-a-cognitive-model-of-peoples-rankings">Could this be used as a cognitive model of people’s rankings?</h2>
<p><img src="https://media.giphy.com/media/dXcwxFuXCd8sI3VcFb/giphy.gif" class="img-fluid"></p>
<p>Maybe. And I enter here in the realm of half baked research, ideal for a blog post.</p>
<p><span class="citation" data-cites="Lee2014">Lee, Steyvers, and Miller (<a href="#ref-Lee2014" role="doc-biblioref">2014</a>)</span> show the implementation of a cognitive model for rank order data from the latent knowledge of participants, which is based on Thurstonian models <span class="citation" data-cites="thurstone1927law thurstone1931rank">(<a href="#ref-thurstone1927law" role="doc-biblioref">Thurstone 1927</a>, <a href="#ref-thurstone1931rank" role="doc-biblioref">1931</a>)</span> fitted with Bayesian methods in JAGS <span class="citation" data-cites="Johnson2013">(<a href="#ref-Johnson2013" role="doc-biblioref">Johnson and Kuhn 2013</a>)</span>.</p>
<p>The exploded logit model seems to be closely related to the Thurstonian model. The Thurstonian model assumes that each participant assigns an underlying score to each item of a set, which is drawn from a true score with normally distributed error. The score determines the order that the participant gives. We can think about the exploded logit similarly. While I modeled the underlying ranking based on probability values, one could assume that each participant <span class="math inline">\(s\)</span> had their own score <span class="math inline">\(\mu_{is}\)</span> for each item (or pizza topping) <span class="math inline">\(i\)</span>, which is built as a common score <span class="math inline">\(\mu_i\)</span> together with some individual deviation <span class="math inline">\(\epsilon_{is}\)</span>:</p>
<p><span class="math display">\[
\mu_{is} = \mu_i + \epsilon_{is}
\]</span></p>
<p>If we assume that <span class="math inline">\(\epsilon_{is}\)</span> has a <a href="https://en.wikipedia.org/wiki/Gumbel_distribution">Gumbel</a> distribution, then the probability of <span class="math inline">\(\mu_{is}\)</span> being ranked first out of N options is determined by a softmax function:</p>
<p><span class="math display">\[
P(i) = \frac{\exp(\mu_i)}{\sum \exp(\mu)}
\]</span></p>
<p>where <span class="math inline">\(\mu\)</span> is the vector of scores for all elements of the set.</p>
<p>And the probability of ordering <span class="math inline">\(j\)</span> second is:</p>
<p><span class="math display">\[
P(i,j,\ldots) = \frac{\exp(\mu_j)}{\sum \exp(\mu_{[-i]})}
\]</span></p>
<p>and so forth.</p>
<p>These last equations are essentially the same categorical distributions that I used before, but the softmax function converts the unbounded scores into probabilities first. However, with the exploded logit, the error term goes away leading to a more tractable model. This is not the case for the Thurstonian model. The Thurstonian model is more complex, but at the same time we gain more flexibility. With the error term, the Thurstonian model can incorporate the reliability of the participants’ judgments and even correlations, which, as far as I know, can’t be included in the exploded logit model.</p>
</section>
<section id="how-to-cite-this-post" class="level2">
<h2 class="anchored" data-anchor-id="how-to-cite-this-post">How to cite this post</h2>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Citation
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>BibTeX:</strong></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bibtex code-with-copy"><code class="sourceCode bibtex"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="va">@misc</span>{<span class="ot">nicenboim2026asimplewaytomodelrankingswithstan</span>,</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">author</span> = {Nicenboim, Bruno},</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">title</span> = {A simple way to model rankings with Stan},</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">year</span> = {2026},</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">month</span> = {januari},</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">url</span> = {https://bruno.nicenboim.me/posts/posts/2026-01-07-a-simple-way-to-model-rankings-with-stan/},</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">doi</span> = {10.5281/zenodo.18171805}</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>APA:</strong></p>
<p>Nicenboim, B. (2026, januari 07). <em>A simple way to model rankings with Stan</em>. https://doi.org/10.5281/zenodo.18171805</p>
</div>
</div>
</div>
</section>
<section id="session-info" class="level2">
<h2 class="anchored" data-anchor-id="session-info">Session info</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>R version 4.5.0 (2025-04-11)
Platform: x86_64-pc-linux-gnu
Running under: Ubuntu 22.04.5 LTS

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/atlas/libblas.so.3.10.3 
LAPACK: /usr/lib/x86_64-linux-gnu/atlas/liblapack.so.3.10.3;  LAPACK version 3.10.0

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=nl_NL.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=nl_NL.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=nl_NL.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=nl_NL.UTF-8 LC_IDENTIFICATION=C       

time zone: Europe/Amsterdam
tzcode source: system (glibc)

attached base packages:
[1] stats     graphics  grDevices utils     datasets 
[6] methods   base     

other attached packages:
[1] bayesplot_1.12.0  cmdstanr_0.9.0    rcorpora_2.0.1   
[4] extraDistr_1.10.0 ggplot2_3.5.2     tidytable_0.11.2 

loaded via a namespace (and not attached):
 [1] gtable_0.3.6         jsonlite_2.0.0      
 [3] dplyr_1.1.4          compiler_4.5.0      
 [5] tidyselect_1.2.1     Rcpp_1.1.0          
 [7] stringr_1.5.1        scales_1.4.0        
 [9] yaml_2.3.10          fastmap_1.2.0       
[11] plyr_1.8.9           R6_2.6.1            
[13] labeling_0.4.3       generics_0.1.4      
[15] distributional_0.5.0 knitr_1.50          
[17] htmlwidgets_1.6.4    backports_1.5.0     
[19] checkmate_2.3.2      tibble_3.3.0        
[21] pillar_1.11.1        RColorBrewer_1.1-3  
[23] posterior_1.6.1      rlang_1.1.6         
[25] stringi_1.8.7        xfun_0.52           
[27] cli_3.6.5            withr_3.0.2         
[29] magrittr_2.0.4       ps_1.9.1            
[31] processx_3.8.6       digest_0.6.37       
[33] grid_4.5.0           lifecycle_1.0.4     
[35] vctrs_0.6.5          tensorA_0.36.2.1    
[37] evaluate_1.0.3       glue_1.8.0          
[39] data.table_1.18.0    farver_2.1.2        
[41] abind_1.4-8          reshape2_1.4.4      
[43] rmarkdown_2.29       matrixStats_1.5.0   
[45] tools_4.5.0          pkgconfig_2.0.3     
[47] htmltools_0.5.8.1   </code></pre>
</div>
</div>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Barsalou1985" class="csl-entry" role="listitem">
Barsalou, Lawrence W. 1985. <span>“Ideals, Central Tendency, and Frequency of Instantiation as Determinants of Graded Structure in Categories.”</span> <em>Journal of Experimental Psychology: Learning, Memory, and Cognition</em> 11 (4): 629.
</div>
<div id="ref-BEGGS19811" class="csl-entry" role="listitem">
Beggs, S, S Cardell, and J Hausman. 1981. <span>“Assessing the Potential Demand for Electric Cars.”</span> <em>Journal of Econometrics</em> 17 (1): 1–19. https://doi.org/<a href="https://doi.org/10.1016/0304-4076(81)90056-7">https://doi.org/10.1016/0304-4076(81)90056-7</a>.
</div>
<div id="ref-gakisetal2018" class="csl-entry" role="listitem">
Gakis, Konstantinos, Panos Pardalos, Chang-Hwan Choi, Jae-Hyeon Park, and Jiwun Yoon. 2018. <span>“Simulation of a Probabilistic Model for Multi-Contestant Races.”</span> <em>Athens Journal of Sports</em> 5 (2): 95–114.
</div>
<div id="ref-Johnson2013" class="csl-entry" role="listitem">
Johnson, Timothy R., and Kristine M. Kuhn. 2013. <span>“Bayesian <span>Thurstonian</span> Models for Ranking Data Using <span>JAGS</span>.”</span> <em>Behavior Research Methods</em> 45 (3): 857–72. <a href="https://doi.org/10.3758/s13428-012-0300-3">https://doi.org/10.3758/s13428-012-0300-3</a>.
</div>
<div id="ref-Lee2014" class="csl-entry" role="listitem">
Lee, Michael D., Mark Steyvers, and Brent Miller. 2014. <span>“A Cognitive Model for Aggregating People’s Rankings.”</span> <em>PLOS ONE</em> 9 (5): e96431. <a href="https://doi.org/10.1371/journal.pone.0096431">https://doi.org/10.1371/journal.pone.0096431</a>.
</div>
<div id="ref-Luce1959" class="csl-entry" role="listitem">
Luce, R. Duncan. 1959. <em>Individual Choice Behavior : A Theoretical Analysis</em>. Book. Wiley N.Y.
</div>
<div id="ref-Plackett" class="csl-entry" role="listitem">
Plackett, R. L. 1975. <span>“The Analysis of Permutations.”</span> <em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em> 24 (2): 193–202. <a href="http://www.jstor.org/stable/2346567">http://www.jstor.org/stable/2346567</a>.
</div>
<div id="ref-taltsValidatingBayesianInference2018" class="csl-entry" role="listitem">
Talts, Sean, Michael Betancourt, Daniel Simpson, Aki Vehtari, and Andrew Gelman. 2018. <span>“Validating <span>Bayesian Inference Algorithms</span> with <span>Simulation</span>-<span>Based Calibration</span>,”</span> April. <a href="http://arxiv.org/abs/1804.06788">http://arxiv.org/abs/1804.06788</a>.
</div>
<div id="ref-thurstone1927law" class="csl-entry" role="listitem">
Thurstone, Louis L. 1927. <span>“A Law of Comparative Judgement.”</span> <em>Psychological Reviews</em> 34: 273–86.
</div>
<div id="ref-thurstone1931rank" class="csl-entry" role="listitem">
———. 1931. <span>“Rank Order as a Psycho-Physical Method.”</span> <em>Journal of Experimental Psychology</em> 14 (3): 187.
</div>
</div>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>This model is also called the <em>rank ordered logit model</em> <span class="citation" data-cites="BEGGS19811">(<a href="#ref-BEGGS19811" role="doc-biblioref">Beggs, Cardell, and Hausman 1981</a>)</span> or Plackett–Luce model due to <span class="citation" data-cites="Plackett">Plackett (<a href="#ref-Plackett" role="doc-biblioref">1975</a>)</span> and <span class="citation" data-cites="Luce1959">Luce (<a href="#ref-Luce1959" role="doc-biblioref">1959</a>)</span>, but I liked the explosion part more.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div>MIT</div></div></section></div></main> <!-- /main -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Find the TOC
  const toc = document.querySelector('#TOC');
  
  if (toc) {
    // Create recent posts section
    const postsSection = document.createElement('div');
    postsSection.className = 'recent-posts-sidebar';
    postsSection.innerHTML = `
      <h2>Posts</h2>
      <ul id="recent-posts-list">
        <li>Loading...</li>
      </ul>
    `;
    
    // Insert after the TOC list
    toc.appendChild(postsSection);
    
    // Fetch and display posts
    fetchRecentPosts();
  }
});

async function fetchRecentPosts() {
  try {
    const response = await fetch('/posts/');
    const html = await response.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // Get all post items
    const postItems = doc.querySelectorAll('.quarto-post');
    
    const posts = [];
    postItems.forEach((item, index) => {
      if (index < 5) {
        const titleLink = item.querySelector('h3.listing-title a');
        const dateEl = item.querySelector('.listing-date');
        
        if (titleLink) {
          const href = titleLink.getAttribute('href');
          // Extract just the path part (remove domain if present)
          const url = href.replace(/^https?:\/\/[^\/]+/, '');
          
          posts.push({
            title: titleLink.textContent.trim(),
            url: url,
            date: dateEl ? dateEl.textContent.trim() : ''
          });
        }
      }
    });
    
    const listEl = document.getElementById('recent-posts-list');
    if (posts.length > 0) {
      listEl.innerHTML = posts.map(post => 
        `<li>
          <a href="${post.url}">${post.title}</a>
          ${post.date ? `<br><small>${post.date}</small>` : ''}
        </li>`
      ).join('') + '<li><a href="/posts/">See all posts...</a></li>';
    } else {
      listEl.innerHTML = '<li><a href="/posts/">View posts</a></li>';
    }
  } catch (error) {
    console.error('Error fetching posts:', error);
    document.getElementById('recent-posts-list').innerHTML = '<li><a href="/posts/">View posts</a></li>';
  }
}
</script>
<script data-goatcounter="https://bnicenboim.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/bruno\.nicenboim\.me");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Licensed under <a href="https://github.com/bnicenboim/bnicenboim.github.io/blob/master/LICENSE">MIT</a></p>
</div>   
    <div class="nav-footer-center">
<p>© 2021-2026 Bruno Nicenboim</p>
</div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../LICENSE.html">
<p>License</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>