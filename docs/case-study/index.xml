<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Case-studies on Bruno Nicenboim</title>
    <link>/case-study/</link>
    <description>Recent content in Case-studies on Bruno Nicenboim</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Jun 2025 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/case-study/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Case study: Mixture modeling of nasalization in Basque</title>
      <link>/case-study/mixture/mixture-nasal/</link>
      <pubDate>Fri, 13 Jun 2025 00:00:00 +0000</pubDate>
      
      <guid>/case-study/mixture/mixture-nasal/</guid><description>


&lt;pre class=&#34;r fold-hide&#34;&gt;&lt;code&gt;## Global options
options(max.print = &amp;quot;75&amp;quot;,
        width = 80,
        tibble.width = 80)
options(scipen = 1, digits = 2)
knitr::opts_chunk$set(echo = TRUE,
                    cache = TRUE,
                    prompt = FALSE,
                    cache.lazy = FALSE,
                    tidy = FALSE,
                    comment = NA,
                    message = FALSE,
                    warning = TRUE)
knitr::opts_knit$set(width = 80)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed)&lt;/code&gt;&lt;/pre&gt;
&lt;style&gt;
.exercise {
  border: 2px solid #007ACC;
  background-color: #f0f8ff;
  padding: 1em;
  margin: 1em 0;
  border-radius: 6px;
}

.exercise h3 {
  margin-top: 0;
  color: #005a9c;
}

.note {
  border-left: 5px solid #1e90ff;
  background-color: #eef6fc;
  padding: 1em;
  margin: 1em 0;
}

.warning {
  border-left: 5px solid #d9534f;
  background-color: #fdf2f2;
  padding: 1em;
  margin: 1em 0;
}
&lt;/style&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This case study examines how &lt;em&gt;nasalance&lt;/em&gt; varies across three etymological categories of Basque aspirates: &lt;strong&gt;oral&lt;/strong&gt;, &lt;strong&gt;contact-nasalized&lt;/strong&gt; (i.e., following a nasal consonant), and historically &lt;strong&gt;nasalized&lt;/strong&gt; aspirates that are reported to be in flux.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;set-up&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Set-up&lt;/h1&gt;
&lt;div id=&#34;packages&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Packages&lt;/h2&gt;
&lt;p&gt;The analysis relies on &lt;strong&gt;tidytable&lt;/strong&gt; for fast data manipulation, &lt;strong&gt;cmdstanr&lt;/strong&gt; for Stan interfacing, and a handful of tidy-Bayes helpers for visualisation and model comparison.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidytable) # nice alternative to dplyr
library(cmdstanr)
library(posterior)
library(bayesplot)
library(brms)
library(ggplot2)
library(loo)
options(mc.cores = 4)
knitr::write_bib(.packages(), &amp;quot;r-references.bib&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;files&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Files&lt;/h2&gt;
&lt;p&gt;We’ll use the following files&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./nas_data.RDS&#34;&gt;&lt;code&gt;nas_data.RDS&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./beta2.stan&#34;&gt;&lt;code&gt;beta2.stan&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./mix.stan&#34;&gt;&lt;code&gt;mix.stan&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./nonmix.stan&#34;&gt;&lt;code&gt;nonmix.stan&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./mix_s.stan&#34;&gt;&lt;code&gt;mix_s.stan&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./mix_s2.stan&#34;&gt;&lt;code&gt;mix_s2.stan&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./mixture-nasal.Rmd&#34;&gt;&lt;code&gt;mixture-nasal.Rmd&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;data-from-iñigo-urrestarazu-porta&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data from Iñigo Urrestarazu-Porta&lt;/h2&gt;
&lt;p&gt;Basque speakers of the Zuberoan variety were recorded with a nasometer. The etymology has three relevant levels:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;strong&gt;contact&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nasalized&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;oral&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r fold-hide&#34;&gt;&lt;code&gt;nas_data &amp;lt;- readRDS(&amp;quot;nas_data.RDS&amp;quot;) |&amp;gt;
  rename(
    etymology = E,
    root = R,
    speaker = S,
    nasalance = N
  ) |&amp;gt;
  filter(!is.na(nasalance)) |&amp;gt;
  filter(etymology != &amp;quot;assimilated&amp;quot;) |&amp;gt;
  mutate(
    E = as.factor(etymology) |&amp;gt; as.numeric(),
    R = as.factor(root) |&amp;gt; as.numeric(),
    speaker = as.factor(speaker) |&amp;gt; as.numeric()
  )&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nas_data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tidytable: 699 × 6
   speaker root     etymology nasalance     E     R
     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;         &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
 1       1 diharu   nasalized     0.102     2    26
 2       1 ihakin   oral          0.136     3    37
 3       1 ihaute   nasalized     0.170     2    41
 4       1 ihintz   nasalized     0.219     2    44
 5       1 ahate    nasalized     0.232     2     8
 6       1 zehe     nasalized     0.144     2    64
 7       1 kahixka  nasalized     0.300     2    46
 8       1 ehe-no   nasalized     0.128     2    28
 9       1 ehe-no   nasalized     0.128     2    28
10       1 halahola oral          0.215     3    36
# ℹ 689 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The quick summary below confirms the expected ranking: &lt;em&gt;contact&lt;/em&gt; tokens are the most nasal, &lt;em&gt;oral&lt;/em&gt; tokens the least, and the &lt;em&gt;nasalized&lt;/em&gt; class falls somewhere in between.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(summary &amp;lt;- nas_data |&amp;gt;
  summarize(
    mean = mean(nasalance),
    sd = sd(nasalance),
    SE = sd(nasalance) / sqrt(n()),
    lq = quantile(nasalance, 0.025),
    hq = quantile(nasalance, 0.975),
    .by = c(&amp;quot;etymology&amp;quot;, &amp;quot;E&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tidytable: 3 × 7
  etymology     E  mean     sd      SE     lq    hq
  &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 contact       1 0.543 0.115  0.0145  0.310  0.749
2 nasalized     2 0.233 0.176  0.00863 0.0536 0.719
3 oral          3 0.166 0.0993 0.00668 0.0536 0.460&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r fold-hide&#34;&gt;&lt;code&gt;ggplot(nas_data, aes(x = nasalance, fill = etymology, color = etymology)) +
  geom_density(alpha = 0.5, linewidth = 1.2) +
  labs(
    title = &amp;quot;Distribution of nasalance by etymology&amp;quot;,
    x = &amp;quot;Nasalance (N)&amp;quot;,
    y = &amp;quot;Density&amp;quot;
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We are modelling proportions of nasalance, with a categorical predictor (etymological category or group), to try to understand if &lt;em&gt;some&lt;/em&gt; aspirates /h/ are nasalized in Basque.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assumptions:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Orals&lt;/strong&gt; should have low proportion values (~20%).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Contact&lt;/strong&gt; refers to aspirates after a nasal consonant, so they should have high values (~50–60%).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Nasalized&lt;/strong&gt; aspirates are being lost in the language:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some speakers never produce them as such (N ~20%).&lt;/li&gt;
&lt;li&gt;Even among those who maintain the distinction, some lexical items have lost nasality.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The core research question is therefore whether the &lt;em&gt;nasalized&lt;/em&gt; category is best described by a &lt;strong&gt;mixture&lt;/strong&gt; of two latent sub-processes.&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;modeling-the-mixture-of-two-components&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Modeling the mixture of two components&lt;/h1&gt;
&lt;p&gt;We focus here on a two-component mixture model &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-NicenboimEtAl2025&#34;&gt;Nicenboim, Schad, and Vasishth 2025&lt;/a&gt;)&lt;/span&gt;, where each component represents a distinct cognitive process. The latent vector &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{z}\)&lt;/span&gt; indicates which component an observation belongs to:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34; id=&#34;eq:mixz&#34;&gt;\[\begin{equation}
\begin{aligned}
z_n \sim \mathit{Bernoulli}(\theta)\\
y_n \sim
\begin{cases}
p_1(\Theta_1), &amp;amp; \text{ if } z_n =1 \\
p_2(\Theta_2), &amp;amp; \text{ if } z_n=0
\end{cases}
\end{aligned}
\tag{1}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In this specific case, &lt;span class=&#34;math inline&#34;&gt;\(y_n\)&lt;/span&gt; is the observed nasalance of a historically nasalized root, and the latent binary indicator &lt;span class=&#34;math inline&#34;&gt;\(z_n\)&lt;/span&gt; determines whether the token was produced via the &lt;em&gt;contact-like&lt;/em&gt; process &lt;span class=&#34;math inline&#34;&gt;\((p_1)\)&lt;/span&gt; or the &lt;em&gt;oral-like&lt;/em&gt; process &lt;span class=&#34;math inline&#34;&gt;\((p_2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;div id=&#34;data-simulation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data simulation&lt;/h2&gt;
&lt;p&gt;In the next few chunks we generate two artificial data sets so that we can stress-test our models: one &lt;strong&gt;true mixture&lt;/strong&gt; and one &lt;strong&gt;true non-mixture&lt;/strong&gt;. We ignore subject‑level variability for now.&lt;/p&gt;
&lt;div id=&#34;a-custom-beta-parameterisation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;A custom Beta parameterisation&lt;/h3&gt;
&lt;p&gt;Before simulating, we re-express the Beta distribution in terms of a more intuitive mean/&lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; parameterisation. The helper functions &lt;code&gt;beta_pars()&lt;/code&gt; and &lt;code&gt;rbeta2()&lt;/code&gt; &lt;em&gt;only&lt;/em&gt; wrap the algebra–they do not affect inference later on, but they make simulation vastly more readable.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\text{var} &amp;lt; \mu (1 - \mu), \quad
\nu = \frac{\mu(1 - \mu)}{\text{var}} - 1, \quad
\alpha = \mu \nu, \quad \beta = (1 - \mu) \nu
\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;beta_pars &amp;lt;- function(mean, sd) {
  var &amp;lt;- sd^2
  alpha &amp;lt;- ((1 - mean) / var - 1 / mean) * mean^2
  beta &amp;lt;- alpha * (1 / mean - 1)
  list(alpha = alpha, beta = beta)
}

rbeta2 &amp;lt;- function(n, mean, sd) {
  pars &amp;lt;- beta_pars(mean, sd)
  rbeta(n = n, shape1 = pars$alpha, shape2 = pars$beta)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;simulate-data-from-a-mixture-process&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Simulate data from a &lt;em&gt;mixture&lt;/em&gt; process&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;prob_nas&lt;/code&gt; below is the root-level probability that a historically nasalised aspirate is realised via a “high-nasalance mechanism” (as in contact condition). By varying this single probability you can dial-in anything from a pure-contact to a pure-oral realisation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(99)
N &amp;lt;- 100

true &amp;lt;- list(
  mu_oral = 0.166,
  sigma_oral = 0.0993,
  mu_contact = 0.543,
  sigma_contact = 0.115,
  prob_nas = 0.15 # made-up probability of nasalization
)

nas_oral &amp;lt;- rbeta2(N, mean = true$mu_oral, sd = true$sigma_oral)
nas_contact &amp;lt;- rbeta2(N, mean = true$mu_contact, sd = true$sigma_contact)

is_nas &amp;lt;- rbinom(N, size = 1, prob = true$prob_nas)
nas_nasalized &amp;lt;- ifelse(
  is_nas == 1,
  rbeta2(N, mean = true$mu_contact, sd = true$sigma_contact), # contact
  rbeta2(N, mean = true$mu_oral, sd = true$sigma_oral)         # oral
)

mix_data &amp;lt;- tidytable(
  etymology = rep(c(&amp;quot;oral&amp;quot;, &amp;quot;contact&amp;quot;, &amp;quot;nasalized&amp;quot;), each = N),
  nasalance = c(nas_oral, nas_contact, nas_nasalized)
) |&amp;gt;
  mutate(E = as.factor(etymology) |&amp;gt; as.numeric())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check distribution and visualize:&lt;/p&gt;
&lt;pre class=&#34;r fold-hide&#34;&gt;&lt;code&gt;mix_data |&amp;gt;
  summarize(
    mean = mean(nasalance),
    sd = sd(nasalance),
    SE = sd(nasalance) / sqrt(n()),
    lq = quantile(nasalance, 0.025),
    hq = quantile(nasalance, 0.975),
    .by = c(&amp;quot;etymology&amp;quot;, &amp;quot;E&amp;quot;)
  )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tidytable: 3 × 7
  etymology     E  mean     sd      SE     lq    hq
  &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 contact       1 0.551 0.119  0.0119  0.323  0.744
2 nasalized     2 0.215 0.169  0.0169  0.0203 0.687
3 oral          3 0.157 0.0895 0.00895 0.0330 0.374&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r fold-hide&#34;&gt;&lt;code&gt;ggplot(mix_data, aes(x = nasalance, fill = etymology, color = etymology)) +
  geom_density(alpha = 0.5, linewidth = 1.2) +
  labs(
    title = &amp;quot;SIMULATED distribution of nasalance by etymology (mixture)&amp;quot;,
    x = &amp;quot;Nasalance (N)&amp;quot;,
    y = &amp;quot;Density&amp;quot;
  ) +
  theme_minimal()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div class=&#34;note&#34;&gt;
&lt;p&gt;Experiment with different values of &lt;code&gt;prob_nas&lt;/code&gt; and observe the effect on the distribution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;simulate-data-from-a-non-mixture-process&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Simulate data from a &lt;em&gt;non-mixture&lt;/em&gt; process&lt;/h3&gt;
&lt;p&gt;Here every category gets its &lt;em&gt;own&lt;/em&gt; Beta distribution. The parameters for &lt;em&gt;oral&lt;/em&gt; and &lt;em&gt;contact&lt;/em&gt; are the same as above; the &lt;em&gt;nasalized&lt;/em&gt; mean/sd are set to match the empirical data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(99)

true2 &amp;lt;- list(
  mu_oral = true$mu_oral,
  sigma_oral = true$sigma_oral,
  mu_contact = true$mu_contact,
  sigma_contact = true$sigma_contact,
  mu_nasalized = 0.233,
  sigma_nasalized = 0.176
)
nas_oral &amp;lt;- rbeta2(N, mean = true2$mu_oral, sd = true2$sigma_oral)
nas_contact &amp;lt;- rbeta2(N, mean = true2$mu_contact, sd = true2$sigma_contact)
nas_nasalized2 &amp;lt;- rbeta2(N, mean = true2$mu_nasalized, sd = true2$sigma_nasalized)

nonmix_data &amp;lt;- tidytable(
  etymology = rep(c(&amp;quot;oral&amp;quot;, &amp;quot;contact&amp;quot;, &amp;quot;nasalized&amp;quot;), each = N),
  nasalance = c(nas_oral, nas_contact, nas_nasalized2)
) |&amp;gt;
  mutate(E = as.factor(etymology) |&amp;gt; as.numeric())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check distribution and visualize:&lt;/p&gt;
&lt;pre class=&#34;r fold-hide&#34;&gt;&lt;code&gt;nonmix_data |&amp;gt; summarize(mean = mean(nasalance),
            sd = sd(nasalance),
            SE = mean(nasalance)/sqrt(n()),
            lq = quantile(nasalance, 0.025),
            hq = quantile(nasalance, 0.975),
            .by = c(&amp;quot;etymology&amp;quot;,&amp;quot;E&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# A tidytable: 3 × 7
  etymology     E  mean     sd     SE     lq    hq
  &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
1 contact       1 0.551 0.119  0.0551 0.323  0.744
2 nasalized     2 0.231 0.183  0.0231 0.0110 0.641
3 oral          3 0.157 0.0895 0.0157 0.0330 0.374&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r fold-hide&#34;&gt;&lt;code&gt;ggplot(nonmix_data, aes(x = nasalance, fill = etymology, color = etymology))  +
  geom_density(alpha = 0.5, linewidth = 1.2) +
  labs(title = &amp;quot;SIMULATED distribution of nasalance by etymology&amp;quot;,
       x = &amp;quot;N&amp;quot;,
       y = &amp;quot;Density&amp;quot;) +
  theme_minimal()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Both distributions are visually similar, underscoring the difficulty of distinguishing the underlying generative processes by eye alone.&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-the-simulated-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Fitting the simulated data&lt;/h2&gt;
&lt;p&gt;We next fit the simulated data sets with &lt;em&gt;both&lt;/em&gt; a mixture and a non-mixture model. We expect the following:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;the mixture model should outperform when the data are a true mixture; and&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;the non-mixture model should win when the data really come from three separate Beta distributions.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;div id=&#34;stan-implementation-two-component-mixture&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Stan implementation: two-component mixture&lt;/h3&gt;
&lt;p&gt;The Stan program below encodes the likelihood&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
  p(y_n\mid\Theta) = \theta\,p_1(y_n\mid\Theta_1) + (1-\theta)\,p_2(y_n\mid\Theta_2),
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(p_1\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(p_2\)&lt;/span&gt; are Beta distributions parameterised by their means and standard deviations. Because Stan does not allow discrete parameters in the &lt;code&gt;parameters&lt;/code&gt; block, we marginalise over the latent indicator $z_n$ via &lt;code&gt;log_sum_exp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Stan model:&lt;/p&gt;
&lt;pre class=&#34;stan&#34;&gt;&lt;code&gt;#include beta2.stan
data {
  int&amp;lt;lower = 1&amp;gt; N;
  vector[N] nasalance;
  array[N] int&amp;lt;lower = 1&amp;gt; E;
}
parameters {
  real&amp;lt;lower = 0, upper = 1&amp;gt; mu_contact;
  real&amp;lt;lower = 0, upper = sqrt(mu_contact*(1-mu_contact))&amp;gt; sigma_contact;
  real&amp;lt;lower = 0, upper = 1 &amp;gt; mu_oral;
  real&amp;lt;lower= 0, upper = sqrt(mu_oral*(1-mu_oral))&amp;gt; sigma_oral;
  real&amp;lt;lower = 0, upper = 1&amp;gt; prob_nas;
}
model {
  // priors for the task component
  target += normal_lpdf(mu_contact | 0.6, 0.2);
  target += normal_lpdf(mu_oral | 0.2, 0.3);
  target += normal_lpdf(sigma_oral | 0, 0.3);
  target += normal_lpdf(sigma_contact | 0, 0.3);

  target += beta_lpdf(prob_nas | 3, 10);

  for(n in 1:N){
    if(E[n] == 1)  // contact
      target +=  beta2_lpdf(nasalance[n] | mu_contact, sigma_contact);
     else if(E[n] == 3)  // oral
       target += beta2_lpdf(nasalance[n] | mu_oral, sigma_oral);
    else if(E[n] == 2) //nas
       target += log_sum_exp(log(prob_nas) +
                  beta2_lpdf(nasalance[n] | mu_contact, sigma_contact),
                  log1m(prob_nas) +
                  beta2_lpdf(nasalance[n] | mu_oral, sigma_oral));
  }
}
generated quantities {
  vector[N] log_lik;
 for(n in 1:N){
    if(E[n] == 1)  // contact
      log_lik[n] =  beta2_lpdf(nasalance[n] | mu_contact, sigma_contact);
     else if(E[n] == 3)  // oral
       log_lik[n] = beta2_lpdf(nasalance[n] | mu_oral, sigma_oral);
     else if(E[n] == 2) //nas
       log_lik[n] = log_sum_exp(log(prob_nas) +
                                beta2_lpdf(nasalance[n] | mu_contact, sigma_contact),
                                log1m(prob_nas) +
                                beta2_lpdf(nasalance[n] | mu_oral, sigma_oral));
  }

  // Posterior predictions:
  vector[N] nasalance_rep;
  for (n in 1:N) {
    if (E[n] == 1)
      nasalance_rep[n] = beta2_rng(mu_contact, sigma_contact);
    else if (E[n] == 3)
      nasalance_rep[n] = beta2_rng(mu_oral, sigma_oral);
    else if (E[n] == 2) {
      if (bernoulli_rng(prob_nas) == 1)
        nasalance_rep[n] = beta2_rng(mu_contact, sigma_contact);
      else
        nasalance_rep[n] = beta2_rng(mu_oral, sigma_oral);
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mix_m &amp;lt;- cmdstan_model(&amp;quot;./mix.stan&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;model-fits&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Model fits&lt;/h3&gt;
&lt;p&gt;Posterior recovery plots (&lt;code&gt;mcmc_recover_hist&lt;/code&gt;) show that all five parameters are recovered when the data truly come from a mixture. Notably, the same Stan model also &lt;em&gt;fits&lt;/em&gt; the non-mixture data well.&lt;/p&gt;
&lt;div id=&#34;fiting-data-generated-by-a-non-mixture-process-with-a-mixture-model&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Fiting data generated by a non-mixture process with a mixture model&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mix_ls &amp;lt;- list(
  N = nrow(mix_data),
  nasalance = mix_data$nasalance,
  E = as.integer(mix_data$E)
)

mixm_mixd &amp;lt;- mix_m$sample(data = mix_ls, parallel_chains = 4)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parameter recovery:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bayesplot::mcmc_recover_hist(
  x = mixm_mixd$draws(c(&amp;quot;mu_oral&amp;quot;, &amp;quot;sigma_oral&amp;quot;, &amp;quot;mu_contact&amp;quot;, &amp;quot;sigma_contact&amp;quot;, &amp;quot;prob_nas&amp;quot;)),
  true = unlist(true)
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;yrep &amp;lt;- mixm_mixd$draws(&amp;quot;nasalance_rep&amp;quot;) |&amp;gt; posterior::as_draws_matrix()
ppc_dens_overlay_grouped(y = mix_data$nasalance, yrep = yrep[1:100, ], group = mix_data$etymology)+ ggtitle(&amp;quot;Mixture model on mixture data&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-non-mixture-data-with-a-mixture-model&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Fitting non-mixture data with a mixture model&lt;/h4&gt;
&lt;p&gt;Data not generated by a mixture model can be perfectly fit by a mixture model!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nonmix_ls &amp;lt;- list(
  N = nrow(nonmix_data),
  nasalance = nonmix_data$nasalance,
  E = as.integer(nonmix_data$E)
)

mixm_nonmixd &amp;lt;- mix_m$sample(data = nonmix_ls, parallel_chains = 4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;yrep &amp;lt;- mixm_nonmixd$draws(&amp;quot;nasalance_rep&amp;quot;) |&amp;gt; posterior::as_draws_matrix()
ppc_dens_overlay_grouped(y = nonmix_data$nasalance, yrep = yrep[1:100, ],group = nonmix_data$etymology)+ ggtitle(&amp;quot;Mixture model on non-mixture data&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;alternative-model-non-mixture-model&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Alternative model: non-mixture model&lt;/h2&gt;
&lt;p&gt;This alternative Stan program replaces the Bernoulli mixture with a dedicated Beta for the nasalised class. Everything else remains the same. This model therefore embodies the (maybe unrealistic) hypothesis that historically nasalised aspirates form a coherent third distribution rather than a mixture of two.&lt;/p&gt;
&lt;p&gt;Stan model:&lt;/p&gt;
&lt;pre class=&#34;stan&#34;&gt;&lt;code&gt;#include beta2.stan
data {
  int&amp;lt;lower = 1&amp;gt; N;
  vector[N] nasalance;
  array[N] int&amp;lt;lower = 1&amp;gt; E;
}
parameters {
  real&amp;lt;lower = 0, upper = 1&amp;gt; mu_contact;
  real&amp;lt;lower = 0, upper = sqrt(mu_contact*(1-mu_contact))&amp;gt; sigma_contact;
  real&amp;lt;lower = 0, upper = 1 &amp;gt; mu_oral;
  real&amp;lt;lower= 0, upper = sqrt(mu_oral*(1-mu_oral))&amp;gt; sigma_oral;
 real&amp;lt;lower = 0, upper = 1&amp;gt; mu_nasalized;
  real&amp;lt;lower = 0, upper = sqrt(mu_nasalized*(1-mu_nasalized))&amp;gt; sigma_nasalized;
}
model {
  // priors for the task component
  target += normal_lpdf(mu_contact | 0.6, 0.2);
  target += normal_lpdf(mu_oral | 0.2, 0.3);
  target += normal_lpdf(mu_nasalized | 0.2, 0.3);
  target += normal_lpdf(sigma_oral | 0, 0.3);
  target += normal_lpdf(sigma_contact | 0, 0.3);
  target += normal_lpdf(sigma_nasalized | 0, 0.3);

  for(n in 1:N){
    if(E[n] == 1)  // contact
      target +=  beta2_lpdf(nasalance[n] | mu_contact, sigma_contact);
     else if(E[n] == 3)  // oral
       target += beta2_lpdf(nasalance[n] | mu_oral, sigma_oral);
    else if(E[n] == 2) //nas
       target += beta2_lpdf(nasalance[n] | mu_nasalized, sigma_nasalized);
  }
}
generated quantities {
  vector[N] log_lik;
  vector[N] nasalance_rep;

  for (n in 1:N) {
    if (E[n] == 1) {  // contact
      log_lik[n] = beta2_lpdf(nasalance[n] | mu_contact, sigma_contact);
      nasalance_rep[n] = beta2_rng(mu_contact, sigma_contact);
    } else if (E[n] == 3) {  // oral
      log_lik[n] = beta2_lpdf(nasalance[n] | mu_oral, sigma_oral);
      nasalance_rep[n] = beta2_rng(mu_oral, sigma_oral);
    } else if (E[n] == 2) {  // nasalized
      log_lik[n] = beta2_lpdf(nasalance[n] | mu_nasalized, sigma_nasalized);
      nasalance_rep[n] = beta2_rng(mu_nasalized, sigma_nasalized);
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;fitting-mixture-and-non-mixture-data-with-a-non-mixture-model&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Fitting mixture and non-mixture data with a non-mixture model&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nonmix_m &amp;lt;- cmdstan_model(&amp;quot;./nonmix.stan&amp;quot;)

nonmixm_mixd &amp;lt;- nonmix_m$sample(data = mix_ls, parallel_chains = 4)
nonmixm_nonmixd &amp;lt;- nonmix_m$sample(data = nonmix_ls, parallel_chains = 4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nonmixm_mixd&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;        variable   mean median   sd  mad     q5    q95 rhat ess_bulk ess_tail
 lp__            223.15 223.47 1.75 1.56 219.71 225.34 1.00     1813     2718
 mu_contact        0.55   0.55 0.01 0.01   0.53   0.57 1.00     4616     2815
 sigma_contact     0.12   0.12 0.01 0.01   0.11   0.13 1.00     4713     2760
 mu_oral           0.16   0.16 0.01 0.01   0.14   0.17 1.00     4842     3373
 sigma_oral        0.10   0.10 0.01 0.01   0.08   0.11 1.00     4589     3023
 mu_nasalized      0.22   0.22 0.02 0.02   0.20   0.25 1.00     4331     2777
 sigma_nasalized   0.16   0.16 0.01 0.01   0.14   0.18 1.00     4025     2499
 log_lik[1]        1.12   1.12 0.07 0.07   1.00   1.24 1.00     5690     3494
 log_lik[2]        1.24   1.24 0.07 0.07   1.11   1.35 1.00     5416     3472
 log_lik[3]        0.84   0.84 0.08 0.08   0.70   0.97 1.00     5775     2994

 # showing 10 of 607 rows (change via &amp;#39;max_rows&amp;#39; argument or &amp;#39;cmdstanr_max_rows&amp;#39; option)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nonmixm_nonmixd&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;        variable   mean median   sd  mad     q5    q95 rhat ess_bulk ess_tail
 lp__            214.49 214.84 1.75 1.53 211.07 216.67 1.00     2090     2769
 mu_contact        0.55   0.55 0.01 0.01   0.53   0.57 1.00     4788     3191
 sigma_contact     0.12   0.12 0.01 0.01   0.11   0.13 1.00     4389     2846
 mu_oral           0.16   0.16 0.01 0.01   0.14   0.17 1.00     4649     3389
 sigma_oral        0.10   0.10 0.01 0.01   0.08   0.11 1.00     4673     2821
 mu_nasalized      0.23   0.23 0.02 0.02   0.21   0.26 1.00     4673     3239
 sigma_nasalized   0.18   0.18 0.01 0.01   0.16   0.20 1.00     3891     2795
 log_lik[1]        1.12   1.13 0.07 0.07   1.00   1.24 1.00     4995     3031
 log_lik[2]        1.24   1.24 0.07 0.07   1.12   1.35 1.00     4894     3185
 log_lik[3]        0.84   0.85 0.08 0.08   0.70   0.97 1.00     5106     3449

 # showing 10 of 607 rows (change via &amp;#39;max_rows&amp;#39; argument or &amp;#39;cmdstanr_max_rows&amp;#39; option)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Recovery of the parameters of the non-mixture with the non-mixture model:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bayesplot::mcmc_recover_hist(
  x = nonmixm_nonmixd$draws(c(&amp;quot;mu_oral&amp;quot;, &amp;quot;sigma_oral&amp;quot;, &amp;quot;mu_contact&amp;quot;, &amp;quot;sigma_contact&amp;quot;, &amp;quot;mu_nasalized&amp;quot;, &amp;quot;sigma_nasalized&amp;quot;)),
  true = unlist(true2)
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-20-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;yrep_mixfit &amp;lt;- nonmixm_mixd$draws(&amp;quot;nasalance_rep&amp;quot;) |&amp;gt; posterior::as_draws_matrix()
ppc_dens_overlay_grouped(
  y = mix_data$nasalance,
  yrep = yrep_mixfit[1:100, ],  
  group = mix_data$etymology
) + ggtitle(&amp;quot;Non-mixture model on mixture data&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-21-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;yrep_nonmixfit &amp;lt;- nonmixm_nonmixd$draws(&amp;quot;nasalance_rep&amp;quot;) |&amp;gt; posterior::as_draws_matrix()
ppc_dens_overlay_grouped(
  y = nonmix_data$nasalance,
  yrep = yrep_nonmixfit[1:100, ],
  group = nonmix_data$etymology
) + ggtitle(&amp;quot;Non-mixture model on non-mixture data&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-22-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;model-comparison&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Model comparison&lt;/h2&gt;
&lt;p&gt;Model comparison via approximate leave-one-out cross-validation (LOO-CV) is rather inconclusive (in this small-data setting):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;loo_mixm_mixd &amp;lt;- loo(mixm_mixd$draws(&amp;quot;log_lik&amp;quot;))
loo_mixm_nonmixd &amp;lt;- loo(mixm_nonmixd$draws(&amp;quot;log_lik&amp;quot;))
loo_nonmixm_mixd &amp;lt;- loo(nonmixm_mixd$draws(&amp;quot;log_lik&amp;quot;))
loo_nonmixm_nonmixd &amp;lt;- loo(nonmixm_nonmixd$draws(&amp;quot;log_lik&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;data-generated-by-a-mixture-process&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Data generated by a mixture process&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;loo_compare(list(mixture_model = loo_mixm_mixd,
                 non_mixture   = loo_nonmixm_mixd))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;              elpd_diff se_diff
mixture_model  0.0       0.0   
non_mixture   -8.1       4.1   &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-generated-by-a-nonmixture-process&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Data generated by a non‑mixture process&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;loo_compare(list(mixture_model = loo_mixm_nonmixd,
                 non_mixture   = loo_nonmixm_nonmixd))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;              elpd_diff se_diff
non_mixture    0.0       0.0   
mixture_model -2.1       3.8   &lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;note&#34;&gt;
&lt;p&gt;Re-run everything changing both seeds to 123. What changes?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;hierarchical-extensions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Hierarchical extensions&lt;/h2&gt;
&lt;p&gt;Real speakers differ in how faithfully they produce nasalised aspirates. The next two Stan programs introduce &lt;strong&gt;speaker-level group effects&lt;/strong&gt; on the mixture weight and, in the final version, also on the contact/oral means via a Cholesky-factor LKJ prior. The high-level structure is unchanged.&lt;/p&gt;
&lt;div id=&#34;subject-level-adjustments-for-the-mixture-weight&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Subject level adjustments for the mixture weight&lt;/h3&gt;
&lt;pre class=&#34;stan&#34;&gt;&lt;code&gt;#include beta2.stan
data {
  int&amp;lt;lower = 1&amp;gt; N;
  vector[N] nasalance;
  array[N] int&amp;lt;lower = 1&amp;gt; E;
  array[N] int&amp;lt;lower = 1&amp;gt; speaker;
  int&amp;lt;lower = 1&amp;gt; N_speaker;
}
parameters {
  real&amp;lt;lower = 0, upper = 1&amp;gt; mu_contact;
  real&amp;lt;lower = 0, upper = sqrt(mu_contact*(1-mu_contact))&amp;gt; sigma_contact;
  real&amp;lt;lower = 0, upper = 1 &amp;gt; mu_oral;
  real&amp;lt;lower= 0, upper = sqrt(mu_oral*(1-mu_oral))&amp;gt; sigma_oral;

  // now it&amp;#39;s log odds
  real&amp;lt;lower = 0, upper = 1&amp;gt; av_prob_nas;

  real&amp;lt;lower = 0&amp;gt;  tau_u;
  vector[N_speaker] z_u;
}
transformed parameters {
  vector[N_speaker] u;
  u = tau_u * z_u;
}
model {
  // priors for the task component
  target += normal_lpdf(mu_contact | 0.6, 0.2);
  target += normal_lpdf(mu_oral | 0.2, 0.3);
  target += normal_lpdf(sigma_oral | 0, 0.3);
  target += normal_lpdf(sigma_contact | 0, 0.3);

  target += std_normal_lpdf(z_u);
  target += normal_lpdf(tau_u | 0, 2);
  
  target += beta_lpdf(av_prob_nas | 3, 10);

  for(n in 1:N){
    if(E[n] == 1)  // contact
      target +=  beta2_lpdf(nasalance[n] | mu_contact, sigma_contact);
     else if(E[n] == 3)  // oral
       target += beta2_lpdf(nasalance[n] | mu_oral, sigma_oral);
    else if(E[n] == 2) { //nas
       real logodds_nas = logit(av_prob_nas) + u[speaker[n]];
       target += log_sum_exp(log_inv_logit(logodds_nas) +
                  beta2_lpdf(nasalance[n] | mu_contact, sigma_contact),
                  log1m_inv_logit(logodds_nas)+
                  beta2_lpdf(nasalance[n] | mu_oral, sigma_oral));
       }
  }
}
generated quantities {
  vector[N] log_lik;
  vector[N] nasalance_rep;
  vector[N_speaker] prob_nas_speaker = inv_logit(logit(av_prob_nas) + u);
  
  for (n in 1:N) {
    if (E[n] == 1) {  // contact
      log_lik[n] = beta2_lpdf(nasalance[n] | mu_contact, sigma_contact);
      nasalance_rep[n] = beta2_rng(mu_contact, sigma_contact);
    } else if (E[n] == 3) {  // oral
      log_lik[n] = beta2_lpdf(nasalance[n] | mu_oral, sigma_oral);
      nasalance_rep[n] = beta2_rng(mu_oral, sigma_oral);
    } else if (E[n] == 2) { // nas
      real logodds_nas = logit(av_prob_nas) + u[speaker[n]];
      real theta = inv_logit(logodds_nas);
      log_lik[n] = log_sum_exp(
        log(theta) + beta2_lpdf(nasalance[n] | mu_contact, sigma_contact),
        log1m(theta) + beta2_lpdf(nasalance[n] | mu_oral, sigma_oral)
      );
      if (bernoulli_rng(theta) == 1)
        nasalance_rep[n] = beta2_rng(mu_contact, sigma_contact);
      else
        nasalance_rep[n] = beta2_rng(mu_oral, sigma_oral);
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mix_s_m &amp;lt;- cmdstan_model(&amp;quot;./mix_s.stan&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We first verify that we can recover the generating parameters. &lt;span class=&#34;citation&#34;&gt;(A complete pipeline would also include SBC, which we omit for brevity: &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-talts2018validating&#34;&gt;Talts et al. 2018&lt;/a&gt;; &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-ModrakEtAl2023&#34;&gt;Modrák et al. 2023&lt;/a&gt;)&lt;/span&gt;. We skip this step here.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nas_ls &amp;lt;- list(N = nrow(nas_data),
               nasalance = nas_data$nasalance,
               E = nas_data$E,
               speaker = nas_data$speaker,
               N_speaker = max(nas_data$speaker))
               
nas_mix &amp;lt;- mix_s_m$sample(data = nas_ls, parallel_chains = 4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;yrep &amp;lt;- nas_mix$draws(&amp;quot;nasalance_rep&amp;quot;) |&amp;gt; posterior::as_draws_matrix()
ppc_dens_overlay_grouped(
  y = nas_data$nasalance,
  yrep = yrep[1:100, ],
  group = nas_data$etymology
) + ggtitle(&amp;quot;Real data&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-28-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r fold-hide&#34;&gt;&lt;code&gt;yrep_mat &amp;lt;- yrep[1:100, ]  # assuming yrep is already created
n_draws &amp;lt;- nrow(yrep_mat)

# Build long dataframe from yrep and attach metadata
yrep_df &amp;lt;- as.data.frame(t(yrep_mat)) |&amp;gt;
  setNames(paste0(&amp;quot;draw&amp;quot;, 1:n_draws)) |&amp;gt;
  mutate(
    obs = nas_data$nasalance,
    speaker = nas_data$speaker,
    etymology = nas_data$etymology
  ) |&amp;gt;
  pivot_longer(
    cols = starts_with(&amp;quot;draw&amp;quot;),
    names_to = &amp;quot;draw&amp;quot;,
    values_to = &amp;quot;yrep&amp;quot;
  )

# Plot
ggplot(yrep_df, aes(x = etymology, y = yrep, fill = etymology)) +
  geom_violin(alpha = 0.5, scale = &amp;quot;width&amp;quot;) +
  geom_point(aes(y = obs), shape = 21, size = 1.5, position = position_jitter(width = 0.1)) +
  facet_wrap(~ speaker, scales = &amp;quot;free_y&amp;quot;) +
  labs(title = &amp;quot;Posterior predictive violins per speaker and etymology&amp;quot;,
       x = &amp;quot;Etymology&amp;quot;, y = &amp;quot;Nasalance&amp;quot;) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-29-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Are there subjects who nasalize more?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mcmc_intervals(nas_mix$draws(&amp;quot;prob_nas_speaker&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-30-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div class=&#34;note&#34;&gt;
&lt;p&gt;Add an analogous parameter &lt;code&gt;w&lt;/code&gt; which modulates the probability of nasalization by &lt;code&gt;root&lt;/code&gt;. Which roots are most likely to be nasalized?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;subject-level-adjustments-for-the-mixture-weight-and-mean-nasalization.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Subject level adjustments for the mixture weight and mean nasalization.&lt;/h3&gt;
&lt;p&gt;A more comprehensive hierarchical model allows &lt;code&gt;mu_contact&lt;/code&gt; and &lt;code&gt;mu_oral&lt;/code&gt;&lt;a href=&#34;/case-study/mixture/mixture-nasal/#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; to vary by speaker and/or by root.&lt;/p&gt;
&lt;p&gt;Stan code:&lt;/p&gt;
&lt;pre class=&#34;stan&#34;&gt;&lt;code&gt;#include beta2.stan
data {
  int&amp;lt;lower = 1&amp;gt; N;
  vector[N] nasalance;
  array[N] int&amp;lt;lower = 1&amp;gt; E;
  array[N] int&amp;lt;lower = 1&amp;gt; speaker;
  int&amp;lt;lower = 1&amp;gt; N_speaker;
}
parameters {
  real&amp;lt;lower = 0, upper = 1&amp;gt; mu_contact;
  real&amp;lt;lower = 0, upper = sqrt(mu_contact*(1-mu_contact))&amp;gt; sigma_contact;
  real&amp;lt;lower = 0, upper = 1 &amp;gt; mu_oral;
  real&amp;lt;lower= 0, upper = sqrt(mu_oral*(1-mu_oral))&amp;gt; sigma_oral;

  // now it&amp;#39;s log odds
  real&amp;lt;lower = 0, upper = 1&amp;gt; av_prob_nas;

 vector&amp;lt;lower = 0&amp;gt;[3]  tau_u;
  matrix[3, N_speaker] z_u;
  cholesky_factor_corr[3] L_u;
}
transformed parameters {
  matrix[N_speaker, 3] u;
  u = (diag_pre_multiply(tau_u, L_u) * z_u)&amp;#39;;
}
model {
  // priors for the task component
  target += normal_lpdf(mu_contact | 0.6, 0.2);
  target += normal_lpdf(mu_oral | 0.2, 0.3);
  target += normal_lpdf(sigma_oral | 0, 0.3);
  target += normal_lpdf(sigma_contact | 0, 0.3);

  target += lkj_corr_cholesky_lpdf(L_u | 2);
  target += std_normal_lpdf(to_vector(z_u));
  target += normal_lpdf(tau_u | 0, 2);
  
  target += beta_lpdf(av_prob_nas | 3, 10);

  for(n in 1:N){
      real mu_c_adj = inv_logit(logit(mu_contact) + u[speaker[n], 1]);
      real mu_o_adj = inv_logit(logit(mu_oral) + u[speaker[n], 3]);
      if(E[n] == 1)  // contact
      target +=  beta2_lpdf(nasalance[n] | mu_c_adj, sigma_contact);
     else if(E[n] == 3)  // oral
       target += beta2_lpdf(nasalance[n] | mu_o_adj, sigma_oral);
    else if(E[n] == 2) { //nas
       real logodds_nas = logit(av_prob_nas) + u[speaker[n], 2];
       target += log_sum_exp(log_inv_logit(logodds_nas) +
                  beta2_lpdf(nasalance[n] | mu_c_adj, sigma_contact),
                  log1m_inv_logit(logodds_nas)+
                  beta2_lpdf(nasalance[n] | mu_o_adj, sigma_oral));
       }
  }
}
generated quantities {
  vector[N] log_lik;
  vector[N] nasalance_rep;
  vector[N_speaker] prob_nas_speaker = inv_logit(logit(av_prob_nas) + u[,3]);
  
  for (n in 1:N) {
    real mu_c_adj = inv_logit(logit(mu_contact) + u[speaker[n], 1]);
     real mu_o_adj = inv_logit(logit(mu_oral) + u[speaker[n], 3]);
        if (E[n] == 1) {  // contact
      log_lik[n] = beta2_lpdf(nasalance[n] | mu_c_adj, sigma_contact);
      nasalance_rep[n] = beta2_rng(mu_c_adj, sigma_contact);
    } else if (E[n] == 3) {  // oral
      log_lik[n] = beta2_lpdf(nasalance[n] | mu_o_adj, sigma_oral);
      nasalance_rep[n] = beta2_rng(mu_o_adj, sigma_oral);
    } else if (E[n] == 2) { // nas
      real logodds_nas = logit(av_prob_nas) + u[speaker[n], 3];
      real theta = inv_logit(logodds_nas);
      log_lik[n] = log_sum_exp(
        log(theta) + beta2_lpdf(nasalance[n] | mu_c_adj, sigma_contact),
        log1m(theta) + beta2_lpdf(nasalance[n] | mu_o_adj, sigma_oral)
      );
      if (bernoulli_rng(theta) == 1)
        nasalance_rep[n] = beta2_rng(mu_c_adj, sigma_contact);
      else
        nasalance_rep[n] = beta2_rng(mu_o_adj, sigma_oral);
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mix_s2_m &amp;lt;- cmdstan_model(&amp;quot;./mix_s2.stan&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nas2_mix &amp;lt;- mix_s2_m$sample(data = nas_ls, parallel_chains = 4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nas2_mix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;      variable   mean median   sd  mad     q5    q95 rhat ess_bulk ess_tail
 lp__          546.59 546.95 6.15 6.29 536.10 556.04 1.00      955     1777
 mu_contact      0.54   0.54 0.02 0.02   0.51   0.57 1.00     2771     2464
 sigma_contact   0.13   0.13 0.01 0.01   0.11   0.14 1.00     3288     2848
 mu_oral         0.16   0.16 0.01 0.01   0.15   0.18 1.00     1856     1983
 sigma_oral      0.08   0.08 0.00 0.00   0.08   0.09 1.00     5449     2789
 av_prob_nas     0.15   0.14 0.06 0.05   0.07   0.26 1.00     2133     2315
 tau_u[1]        0.17   0.16 0.09 0.08   0.04   0.32 1.00     1266     1301
 tau_u[2]        1.68   1.57 0.63 0.54   0.89   2.87 1.00     1718     2197
 tau_u[3]        0.19   0.18 0.06 0.05   0.12   0.30 1.00     1879     2438
 z_u[1,1]       -0.52  -0.54 0.87 0.83  -1.93   0.91 1.00     2513     3060

 # showing 10 of 1493 rows (change via &amp;#39;max_rows&amp;#39; argument or &amp;#39;cmdstanr_max_rows&amp;#39; option)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;yrep &amp;lt;- nas2_mix$draws(&amp;quot;nasalance_rep&amp;quot;) |&amp;gt; posterior::as_draws_matrix()
ppc_dens_overlay_grouped(
  y = nas_data$nasalance,
  yrep = yrep[1:100, ],
  group = nas_data$etymology
) + ggtitle(&amp;quot;Real data with the more complex model&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/case-study/mixture/mixture-nasal//case-study/mixture/mixture-nasal_files/figure-html/unnamed-chunk-34-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div class=&#34;note&#34;&gt;
&lt;p&gt;Consider additional posterior predictive checks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;notes&#34;&gt;
&lt;p&gt;Consider simulating data.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;note&#34;&gt;
&lt;p&gt;Is the hierarchical mixture model preferable to a hierarchical non-mixture alternative?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Visual similarity is deceptive.&lt;/strong&gt; Simulated mixture and non-mixture data look almost identical.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Model comparison alone can be inconclusive&lt;/strong&gt; at the current sample size: both mixture and non-mixture models achieve very similar LOO‑CV scores on either data-generating process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Speaker-level effects matter.&lt;/strong&gt; Allowing the mixture weight to vary by speaker reveals substantial individual differences.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Domain knowledge remains crucial.&lt;/strong&gt; The structure of the model should be informed by theory.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;session-info&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Session info&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;R version 4.5.0 (2025-04-11)
Platform: x86_64-pc-linux-gnu
Running under: Ubuntu 22.04.5 LTS

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 
LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0  LAPACK version 3.10.0

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=nl_NL.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=nl_NL.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=nl_NL.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=nl_NL.UTF-8 LC_IDENTIFICATION=C       

time zone: Europe/Amsterdam
tzcode source: system (glibc)

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] loo_2.8.0        ggplot2_3.5.2    brms_2.22.0      Rcpp_1.0.14     
[5] bayesplot_1.12.0 posterior_1.6.1  cmdstanr_0.9.0   tidytable_0.11.2

loaded via a namespace (and not attached):
 [1] bridgesampling_1.1-5 tensorA_0.36.2.1     utf8_1.2.6          
 [4] sass_0.4.10          generics_0.1.4       stringi_1.8.7       
 [7] lattice_0.22-5       blogdown_1.21        digest_0.6.37       
[10] magrittr_2.0.3       evaluate_1.0.3       grid_4.5.0          
[13] RColorBrewer_1.1-3   bookdown_0.43        mvtnorm_1.3-3       
[16] fastmap_1.2.0        plyr_1.8.9           Matrix_1.7-3        
[19] jsonlite_2.0.0       processx_3.8.6       backports_1.5.0     
[22] ps_1.9.1             Brobdingnag_1.2-9    scales_1.4.0        
[25] codetools_0.2-19     jquerylib_0.1.4      abind_1.4-8         
[28] cli_3.6.5            rlang_1.1.6          withr_3.0.2         
[31] cachem_1.1.0         yaml_2.3.10          tools_4.5.0         
[34] parallel_4.5.0       reshape2_1.4.4       rstantools_2.4.0    
[37] coda_0.19-4.1        checkmate_2.3.2      dplyr_1.1.4         
[40] vctrs_0.6.5          R6_2.6.1             matrixStats_1.5.0   
[43] lifecycle_1.0.4      stringr_1.5.1        pkgconfig_2.0.3     
[46] RcppParallel_5.1.10  pillar_1.10.2        bslib_0.9.0         
[49] gtable_0.3.6         data.table_1.17.0    glue_1.8.0          
[52] xfun_0.52            tibble_3.3.0         tidyselect_1.2.1    
[55] rstudioapi_0.17.1    knitr_1.50           farver_2.1.2        
[58] nlme_3.1-168         htmltools_0.5.8.1    labeling_0.4.3      
[61] rmarkdown_2.29       compiler_4.5.0       distributional_0.5.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I used R &lt;span class=&#34;citation&#34;&gt;(Version 4.5.0; &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-R-base&#34;&gt;R Core Team 2025&lt;/a&gt;)&lt;/span&gt; and the R-packages &lt;em&gt;bayesplot&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(Version 1.12.0; &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-R-bayesplot&#34;&gt;Gabry and Mahr 2025&lt;/a&gt;)&lt;/span&gt;, &lt;em&gt;brms&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(Version 2.22.0; &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-R-brms&#34;&gt;Bürkner 2024&lt;/a&gt;)&lt;/span&gt;, &lt;em&gt;cmdstanr&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(Version 0.9.0; &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-R-cmdstanr&#34;&gt;Gabry et al. 2025&lt;/a&gt;)&lt;/span&gt;, &lt;em&gt;ggplot2&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(Version 3.5.2; &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-R-ggplot2&#34;&gt;Wickham et al. 2025&lt;/a&gt;)&lt;/span&gt;, &lt;em&gt;loo&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(Version 2.8.0; &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-R-loo&#34;&gt;Vehtari et al. 2024&lt;/a&gt;)&lt;/span&gt;, &lt;em&gt;posterior&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(Version 1.6.1; &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-R-posterior&#34;&gt;Bürkner et al. 2025&lt;/a&gt;)&lt;/span&gt;, &lt;em&gt;Rcpp&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(Version 1.0.14; &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-R-Rcpp&#34;&gt;Eddelbuettel et al. 2025&lt;/a&gt;)&lt;/span&gt; and &lt;em&gt;tidytable&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(Version 0.11.2; &lt;a href=&#34;/case-study/mixture/mixture-nasal/#ref-R-tidytable&#34;&gt;Fairbanks 2024&lt;/a&gt;)&lt;/span&gt; for all our analyses.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references csl-bib-body hanging-indent&#34; entry-spacing=&#34;0&#34;&gt;
&lt;div id=&#34;ref-R-brms&#34; class=&#34;csl-entry&#34;&gt;
Bürkner, Paul-Christian. 2024. &lt;em&gt;Brms: Bayesian Regression Models Using Stan&lt;/em&gt;. &lt;a href=&#34;https://github.com/paul-buerkner/brms&#34;&gt;https://github.com/paul-buerkner/brms&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-R-posterior&#34; class=&#34;csl-entry&#34;&gt;
Bürkner, Paul-Christian, Jonah Gabry, Matthew Kay, and Aki Vehtari. 2025. &lt;em&gt;Posterior: Tools for Working with Posterior Distributions&lt;/em&gt;. &lt;a href=&#34;https://mc-stan.org/posterior/&#34;&gt;https://mc-stan.org/posterior/&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-R-Rcpp&#34; class=&#34;csl-entry&#34;&gt;
Eddelbuettel, Dirk, Romain Francois, JJ Allaire, Kevin Ushey, Qiang Kou, Nathan Russell, Iñaki Ucar, Doug Bates, and John Chambers. 2025. &lt;em&gt;Rcpp: Seamless r and c++ Integration&lt;/em&gt;. &lt;a href=&#34;https://www.rcpp.org&#34;&gt;https://www.rcpp.org&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-R-tidytable&#34; class=&#34;csl-entry&#34;&gt;
Fairbanks, Mark. 2024. &lt;em&gt;Tidytable: Tidy Interface to Data.table&lt;/em&gt;. &lt;a href=&#34;https://markfairbanks.github.io/tidytable/&#34;&gt;https://markfairbanks.github.io/tidytable/&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-R-cmdstanr&#34; class=&#34;csl-entry&#34;&gt;
Gabry, Jonah, Rok Češnovar, Andrew Johnson, and Steve Bronder. 2025. &lt;em&gt;Cmdstanr: R Interface to CmdStan&lt;/em&gt;. &lt;a href=&#34;https://mc-stan.org/cmdstanr/&#34;&gt;https://mc-stan.org/cmdstanr/&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-R-bayesplot&#34; class=&#34;csl-entry&#34;&gt;
Gabry, Jonah, and Tristan Mahr. 2025. &lt;em&gt;Bayesplot: Plotting for Bayesian Models&lt;/em&gt;. &lt;a href=&#34;https://mc-stan.org/bayesplot/&#34;&gt;https://mc-stan.org/bayesplot/&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-ModrakEtAl2023&#34; class=&#34;csl-entry&#34;&gt;
Modrák, Martin, Angie H. Moon, Shinyoung Kim, Paul-Christian Bürkner, Niko Huurre, Kateřina Faltejsková, Andrew Gelman, and Aki Vehtari. 2023. &lt;span&gt;“Simulation-Based Calibration Checking for &lt;span&gt;Bayesian&lt;/span&gt; Computation: &lt;span&gt;The&lt;/span&gt; Choice of Test Quantities Shapes Sensitivity.”&lt;/span&gt; &lt;em&gt;Bayesian Analysis&lt;/em&gt;, 1–28. &lt;a href=&#34;https://doi.org/10.1214/23-BA1404&#34;&gt;https://doi.org/10.1214/23-BA1404&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-NicenboimEtAl2025&#34; class=&#34;csl-entry&#34;&gt;
Nicenboim, Bruno, Daniel J. Schad, and Shravan Vasishth. 2025. &lt;em&gt;Introduction to Bayesian Data Analysis for Cognitive Science&lt;/em&gt;. 1st ed. Chapman; Hall/CRC. &lt;a href=&#34;https://doi.org/10.1201/9780429342646&#34;&gt;https://doi.org/10.1201/9780429342646&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-R-base&#34; class=&#34;csl-entry&#34;&gt;
R Core Team. 2025. &lt;em&gt;R: A Language and Environment for Statistical Computing&lt;/em&gt;. Vienna, Austria: R Foundation for Statistical Computing. &lt;a href=&#34;https://www.R-project.org/&#34;&gt;https://www.R-project.org/&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-talts2018validating&#34; class=&#34;csl-entry&#34;&gt;
Talts, Sean, Michael J. Betancourt, Daniel P. Simpson, Aki Vehtari, and Andrew Gelman. 2018. &lt;span&gt;“Validating &lt;span&gt;B&lt;/span&gt;ayesian Inference Algorithms with Simulation-Based Calibration.”&lt;/span&gt; &lt;em&gt;arXiv Preprint arXiv:1804.06788&lt;/em&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-R-loo&#34; class=&#34;csl-entry&#34;&gt;
Vehtari, Aki, Jonah Gabry, Måns Magnusson, Yuling Yao, Paul-Christian Bürkner, Topi Paananen, and Andrew Gelman. 2024. &lt;em&gt;Loo: Efficient Leave-One-Out Cross-Validation and WAIC for Bayesian Models&lt;/em&gt;. &lt;a href=&#34;https://mc-stan.org/loo/&#34;&gt;https://mc-stan.org/loo/&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-R-ggplot2&#34; class=&#34;csl-entry&#34;&gt;
Wickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen, Kohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, Dewey Dunnington, and Teun van den Brand. 2025. &lt;em&gt;Ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics&lt;/em&gt;. &lt;a href=&#34;https://ggplot2.tidyverse.org&#34;&gt;https://ggplot2.tidyverse.org&lt;/a&gt;.
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes footnotes-end-of-document&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;with considerable extra work we could also deal with &lt;code&gt;sigma&lt;/code&gt;&lt;a href=&#34;/case-study/mixture/mixture-nasal/#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
